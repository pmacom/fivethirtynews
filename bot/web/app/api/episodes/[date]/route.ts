import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';

// Initialize Supabase client
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

/**
 * GET /api/episodes/[date]
 *
 * Fetches episode data for a specific date in WTF-compatible format
 *
 * @param date - Date in YYYY-MM-DD format (e.g., "2025-10-11")
 * @returns LiveViewContentBlock[] format expected by WTF library
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { date: string } }
) {
  try {
    const { date } = params;

    // Validate date format
    if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
      return NextResponse.json(
        { error: 'Invalid date format. Use YYYY-MM-DD' },
        { status: 400 }
      );
    }

    // 1. Get or check if episode exists for this date
    const { data: episode, error: episodeError } = await supabase
      .from('episodes')
      .select('*')
      .eq('date', date)
      .eq('is_published', true)
      .single();

    if (episodeError && episodeError.code !== 'PGRST116') {
      // PGRST116 = no rows returned, which is okay
      throw episodeError;
    }

    if (!episode) {
      return NextResponse.json(
        {
          error: 'Episode not found for this date',
          message: 'No content has been tagged for this date yet',
          date
        },
        { status: 404 }
      );
    }

    // 2. Get all content blocks for this episode with their tag info
    const { data: contentBlocks, error: blocksError } = await supabase
      .from('content_blocks')
      .select(`
        id,
        title,
        description,
        weight,
        episode_id,
        tags!content_blocks_tag_id_fkey (
          id,
          name,
          slug,
          description
        )
      `)
      .eq('episode_id', episode.id)
      .order('weight', { ascending: true });

    if (blocksError) throw blocksError;

    if (!contentBlocks || contentBlocks.length === 0) {
      return NextResponse.json(
        {
          episodeId: episode.id,
          title: episode.title,
          date: episode.date,
          description: episode.description,
          contentBlocks: []
        },
        { status: 200 }
      );
    }

    // 3. Get all content block items with their post data
    const contentBlockIds = contentBlocks.map(cb => cb.id);

    const { data: contentBlockItems, error: itemsError } = await supabase
      .from('content_block_items')
      .select(`
        id,
        note,
        weight,
        content_block_id,
        tagged_posts!content_block_items_post_id_fkey (
          id,
          tweet_id,
          tweet_text,
          author,
          url,
          thumbnail_url,
          timestamp,
          tags,
          category,
          user_id,
          created_at
        )
      `)
      .in('content_block_id', contentBlockIds)
      .order('weight', { ascending: true });

    if (itemsError) throw itemsError;

    // 4. Transform to WTF format
    const wtfContentBlocks = contentBlocks.map(block => {
      // Get items for this content block
      const items = (contentBlockItems || [])
        .filter(item => item.content_block_id === block.id)
        .map((item, index) => {
          const post = item.tagged_posts;

          return {
            id: item.id,
            note: item.note || '',
            weight: item.weight || index,
            content_block_id: block.id,
            news_id: post.tweet_id,
            content: {
              id: post.id,
              version: 1,
              content_type: 'twitter' as const,
              content_url: post.url,
              content_id: post.tweet_id,
              content_created_at: post.timestamp || post.created_at,
              thumbnail_url: post.thumbnail_url || '',
              submitted_by: post.user_id || 'anonymous',
              submitted_at: post.created_at,
              category: post.category || '',
              categories: Array.isArray(post.tags) ? post.tags : [],
              description: post.tweet_text || ''
            }
          };
        });

      return {
        id: block.id,
        title: block.title,
        weight: block.weight || 0,
        episode_id: episode.id,
        description: block.description || '',
        content_block_items: items
      };
    });

    // 5. Return response
    return NextResponse.json(
      {
        episodeId: episode.id,
        title: episode.title,
        date: episode.date,
        description: episode.description,
        isAutoGenerated: episode.is_auto_generated,
        contentBlocks: wtfContentBlocks
      },
      {
        status: 200,
        headers: {
          'Cache-Control': 'public, s-maxage=60, stale-while-revalidate=300'
        }
      }
    );

  } catch (error) {
    console.error('API Error - /api/episodes/[date]:', error);

    return NextResponse.json(
      {
        error: 'Internal server error',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

/**
 * POST /api/episodes/[date]
 *
 * Creates a manual episode for a specific date (admin only)
 *
 * @body title - Episode title
 * @body description - Episode description
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { date: string } }
) {
  try {
    const { date } = params;
    const body = await request.json();

    // Validate date format
    if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
      return NextResponse.json(
        { error: 'Invalid date format. Use YYYY-MM-DD' },
        { status: 400 }
      );
    }

    // Check if episode already exists
    const { data: existing } = await supabase
      .from('episodes')
      .select('id')
      .eq('date', date)
      .single();

    if (existing) {
      return NextResponse.json(
        { error: 'Episode already exists for this date' },
        { status: 409 }
      );
    }

    // Create episode
    const { data: episode, error } = await supabase
      .from('episodes')
      .insert({
        date,
        title: body.title || `Manual Episode - ${date}`,
        description: body.description || '',
        is_auto_generated: false,
        is_published: body.is_published !== false // Default to true
      })
      .select()
      .single();

    if (error) throw error;

    return NextResponse.json(episode, { status: 201 });

  } catch (error) {
    console.error('API Error - POST /api/episodes/[date]:', error);

    return NextResponse.json(
      {
        error: 'Failed to create episode',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
